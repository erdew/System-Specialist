<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>29.04.2023</title>
    <link rel="icon" type="image/x-icon" href="../eg_favicon.JPG">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@200;300;400;600&display=swap" rel="stylesheet"> 
    <style>
      body {
        font-family: 'Source Code Pro', monospace;
        font-size: 14px;
        color: #e2e3e7;
        background-color: #232529;
        /*
        e2e3e7
        c4c7cf
        868d9a
        696e79
        41454c
        35383f
        292c31
        232529

        31333a
        */
      }

      h1 {
        text-align: center;
      }

      h1 > a {
        color: rgb(139, 233, 253);
      }

      h1, h2, h3, h4, h5, h6 {
        color: rgb(139, 233, 253);
      }

      a{
        text-decoration: none;
      }

      a:hover {
        color: #e2e3e7;
      }

      .container {
        max-width: 800px;
        border: 1px solid rgb(139, 233, 253);
        border-radius: 10px;
      }

      .bg-script {
        color: rgb(139, 233, 253);
        background-color: #31333a;
        padding: 20px;
        border: 1px solid rgb(139, 233, 253);
        border-radius: 10px;
        text-align: start;
        font-size: 15px;
        line-height: normal;
      }

      .navigation > a:hover {
        color: #31333a;
        background-color: rgb(139, 233, 253);
      }

    </style>
  </head>
  <body>
    <div class="container p-4 mt-2 mb-5">
        <h1><a href="../index.html" class="display-4">29.04.2023</a></h1>
        
        <hr>

        <h2>SOPHOS Firewall Arayüzü</h2>
        <p class="bg-script">
          > SOPHOS Arayüz; https://192.168.1.2:4444 <br>
        </p>

        <hr>

        <h4>Definations & Users</h4>
        <p>
          Bu başlık kendi içinde 7 başlığa daha kırılıyor.
        </p>

        <h5>Network Definations</h5>
        <p>
          Defination and Users önceden tarif edilmiş olan her şeyin bulunduğu konumdur. <br>
          Herhangi bir kural yazmadan önce ya da kural uygulanmadan önce mutlaka burada onun nereye uygulanacağı ve ne olduğu tarif edilmiş olmalıdır. <br>
          Örneğin; <br>
          Any -> IP'si ne olursa olsun demektir, iç Network dış Network fark etmez. <br>
          Built in olarak bu konumda Any'nin tarif edilmiş olduğunu zaten görüyoruz. <br>
          Buna benzer şekilde farklı farklı Built-in Defination'lar olduğunu da bu konumda görebiliriz. <br>
          Bazı durumlarda, mesela DNS'i Forward ettiğimizde otomatik olarak burada bazı tariflerin açıldığını da görürüz. <br>
          Örneğin Domain Controller makinemizin üzerindeki DNS'i bu Firewall'dan Forward ettiysek otomatik olarak Domain Controller'in bu konumda tarif edildiğini görebiliriz. <br>
          Yani örneğin; Domain Controller'ımızın adı DC01 ve IP'si 192.168.1.2 ise bunun aynen bu şekilde bu konumda tarif edildiğini görürüz. <br>
          Buna benzer şekilde External Network'ü ve Direkt Interface'ini, aynı şekilde Internal Network'ü ve Interface'ini de otoamtik olarak tarif eder. <br>
          Çünkü Firewall yaptığımız bu makinenin de üzerinde Interface'ler bulunuyor, bu bilgiyi direkt olarak kendi üzerinden okuyup, burada tarif edebiliyor. <br>
          Tabiki bulunduğu Network'lerin Broadcast ve Network ID'lerini de tarif eder.
        </p>
       
        <h5>Service Definations</h5>
        <p>
          Bu konumda da DNS, FTP, DHCP, Email Messaging vs. gibi servislerin tanımının yapıldığını görüyoruz. <br>
          Daha sonradan bir hizmet tanımlamak istediğimiz durumda bu konuma gelerek ekle butonu ile direkt olarak tanımlama yapabiliriz. <br>
          Built-in olarak standart verilen hizmetlerin zaten tanımlandığını görüyoruz. <br><br>

          Fakat bir "Service Defination'ın" nasıl olduğuna örnek verecek olursak, şunlardan bahsedebiliriz; <br>
        </p>

        <ol>
          <li>Her Service'in bir ismi vardır;</li>
          <span>Örneğin; DNS. </span>
          <li>Her Service'in tanımlama tipi vardır;</li>
          <span>DNS için; TCP/UDP, yani DNS'in TCP/UDP protokolleriyle çalıştığını tanımlayan madde.</span>
          <li>Her Service'in tanımlama Port'u vardır;</li>
          <span>DNS için; 53</span>
          <li>Her Service'in kaynak Port'u vardır;</li>
          <span>DNS için; 1:65535</span>
        </ol>

        <p>
          Özetle DNS TCP/UDP protokolleriyle 53 numaralı Port'tan dinleme yapabilme marifetine sahip olan bir Service olduğu için tanımlaması tam olarak bu şekilde yapılmıştır. <br>
          Diğer Service'leri tanımlarken onların kullanabildiği Protokol ve Port'lara göre bu maddeler tanımlanır. <br>
          Yani bir Service tanımlamak demek aslında o Service'in Protokollerini ve Port'ları tanımlamak demektir.
        </p>
        

        <h5>Time Period Definitions</h5>
        <p>
          Kuralların hangi saat aralıklarında block'lanacaklarının ya da uygulanacaklarının belirlendiği konumdur. <br>
          Built-in olarak Lunch, Time to install updates, weekend gibi zaman aralıklarının tarif edildiğini görüyoruz. <br>
          Örneğiz biz bu konumdan şirketimizin mesai saatlerini tarif eden bir tanımlama yapabiliriz. <br>
          Fakat tabiki bu konumda sadece tanımlama yapıyoruz, yani tarif ediyoruz. <br>
          Herhangi bir kural yazılmış durumda değil, daha sonradan bu tarifleri kullanarak kurallar tanımlayabileceğiz.
        </p>

        <h5>Users and Groups</h5>
        <p>
          Bu konumda varolan User'larımızın tarifi yapılır. <br>
          Kural yazmak istediğimiz User ve Group'ları bu konumdan tanımlıyoruz. <br>
          Burada Built-in olarak Admin hesabını görürüz. <br>
          Bu hesap Firewall üzerindeki en yetkili hesaptır. <br>
          SuperAdmins grubuna üyedir. <br>
          Bu gruba hangi User'ı üye edersek artık o User da Firewall üzerinde tam yetkiye sahip olur. <br>
          Ayrıca bu konumda Active Directory üzerinden Authentication'ı yapılan User'lar da listelenirler.
        </p>

        <h5>Client Authentication</h5>
        <p>
          User Portal'ımıza hangi Client'ler ve hangi User ya da Group'lar erişebilsin bunun tanımlamasını yaptığımız konumdur. <br>
          Bu konumda Allowed Networks bölümüne örneğin Internal'ı verdiğimizde Network'ümüzden IP alan tüm cihazlar User Portal'a erişebilir anlamına gelir. <br>
          Aynı şekilde Allowed Users and Groups'a eklediğimiz her bir User ya da Group da User Portal'a erişebilir. <br>
          Bu konumda Network'ü ya da direkt olarak cihazları ve User ya da Group'ları tanımladan atlarsak User Portal'a erişimi açsak bile Client Authentication programı erişebilir durumda olmaz. <br>
          Bu sebepte önce burada tanımlama yapılmalı daha sonra Portal aktif hale getirilmeli, aksi durumda zaten Portal'a erişenler bomboş bir sayfa ile karşılaşırlar. <br>
          Client Authentication Program kullanıcıların her defasında giriş yapmasını engelleyen bir Script'tir. <br>
          Program arkaplanda otomatik olarak id şifreyi girer ve Authentication'ı sağlar. <br>
          Global sekmesinde Authentication yapılan hesapların listelendiğini yani yapılan etkileşimi görebiliriz.
        </p>

        <h5>AWS Profiles</h5>
        <p>
          Amazon Web Service, Windows Azure Service'in rakibidir ve dünya genelinde daha fazla kullanılır. <br>
          Sanallaştırma ya da herhangi bir Network Service hizmetini veren bir hizmettir. <br>
          Eğer AWS'den bir hizmet alıyorsak ve Amazon ile birlikte çalışacağımız bir senaryomuz var ise Sophos'a bu ilişkimizi bildirmemiz gerekiyor. <br>
          Bunun içinde AWS Profiles kısmından Add Profile diyerek, Erişim Anahtarımızı giriyoruz. <br>
          Özetle bu tanımlama; AWS üzerinde çalışan bir Network'ümüz yani oradan hizmet veren cihazlarımız var ise o cihazların yani Network'ün üzerinde bu Firewall çalıştırılacak anlamına geliyor.
        </p>

        <h5>Authentication Services</h5>
        <p>
          Bu konumda Domain Controller'ımızı tanımlayıp, bu Firewall'u Domain'e ekleyebiliyoruz. <br>
          Ayrıca Single Sign-On yapabiliyoruz. <br>
          Single Sign-On, Firewall'a Active Directory üzerinden Authentication yapan hesapların Log-on olmasını sağlar. <br>
          Yani sadece admin hesabının değil Domain Admin'in ve Domain'deki diğer hesapların da Log-on olabilmesi sağlanır. <br>
          Ancak admin yetkisi sadece SuperAdmins grubuna üye olan hesaplarda bulunur.
        </p>
        <p>
          Bu ekranda Authentication Cache adında bir bölüm vardır. <br>
          Bu bölümden direkt olarak Authentication Cache silinebilir. <br>
          Hangi durumda bunu kullanmaya ihtiyaç duyabiliriz? <br>
          Örneğin bir User'ın Password'unu değiştirdik, User Log-on olmak istediğinde Firewall o User'ın eski Password'una sahip olabilir. <br>
          Çünkü bu alan bir Cache yani önbellek, dinamik olarak anında değişebilen bir hafıza bölgesi değil. <br>
          O anda bilgi henüz güncellenmemiş olabilir ve bu durumda Authentication sağlanamaz ve kullanıcı Log-on olamaz. <br>
          Bu noktada Cache'i temizleyerek yeni bilginin alınmasını sağlayabiliriz. <br>
          Authentication problemlerinde önce tarih ve saat ayarları kontrol edilmelidir. <br>
          Giriş yapılan cihaz ile Authentication'ı yapacak olan cihaz arasında zaman farkı olmamalıdır. <br>
          Bu tüm Authentication yapılan alanlarda geçerli olan bir durumdur.
        </p>

        <hr>

        <h4>Interfaces and Routing</h4>

        <h5>Interfaces</h5>
        <p>
          Firewall'ın üzerindeki Interface'leri yani Ethernet Port'larını görürüz. <br>
          Bu konumda bir Interface'in devre dışı kalması durumunda diğer bir Interface'ten çalışmaya devam etmesini sağlayacak ayarlar yapılabilir. <br>
          Server üzerinde NIC Teaming adıverilen bir teknolojinin benzeri direkt Firewall üzerinden de uygulanabilir. <br>
          Firewall'lar üzerinde çalıştıkları Network'ler için Gateway olduklarından dolayı o Network'ten yapılan tüm çıkışlar ve girişler Firewall'ın External Interface'inden olacağı anlamına gelir. <br>
          Bu durumda eğer External Interface kaybedilirse, o Network'ün dış dünya ile iletişimi yani internete olan bağlantısı kaybedilir. <br>
          Bunun gibi durumlar için önlem amaçlı olarak ISP'lerden bir hat daha alınabilir. <br>
          Farklı bir ISP'den yine fiber(fakat aynı kabloları kullanmayan) ya da aynı ISP'den farklı bir teknoloji(örneğin vDSL veya GSM) şeklinde yeni bir yedek hat alınabilir. <br>
          Yedek olarak alınan bu hattı Stand-by durumda bekletebiliriz ve ana hattımızda bir kesinti olması durumunda anında devreye girerek durumu anlık olarak kurtarmasını sağlayabiliriz. <br>
        </p>

        <h6>External Interface'lerden birisinin Offline olmasına önlem olarak yapılabilecekler</h6>
        <p>
          Interface sekmesinde Hardware bölümünde makinenin üzerinde Interface'ler görüntülenir. <br>
          Yeni bir External Interface ekliyoruz. <br>
          Kartı taktıktan sonra bu ekranda görüntüleyemiyorsak, makineyi Restart'larız. <br>
          Restart'ladıktan sonra listeleniyor olması gerekiyor. <br>
          Bu noktada Interfaces sekmesinde yeni eklediğimiz Interface'i göremeyiz. <br>
          Çünkü henüz bu Interface'i henüz tanımlamadık. <br>
          Bunun için New Interface'e tıklıyoruz. <br>
          Hardware seçeneğinden eklediğimiz Interface'i seçeriz. <br>
          Type kısmından Ethernet'i seçiyoruz. <br>
          Buradaki Type ile bu hattı hangi cinsten aldıysak onu belirtiyoruz. <br>
          Örneğin 3G olabilir ya da DSK olabilir vs. <br>
          Eğer GSM aldıysak 3G'yi seçebiliriz gibi. <br>
          Biz sanalda bunu Ethernet'e bağlayarak kendi sahip olduğumuz fiziksel External'a çıkacağımız için Ethernet'i seçiyoruz ki uygulayabilelim. <br>
          Özetle ne tür bir internet hattı aldıysak onu bu Interface ile eşleştiriyoruz ya da başka bir değişle onun üzerine tanımlıyoruz. <br>
          Bu Interface'e bir IP atıyoruz, sanalda yaptığımız için yani simüle ettiğimiz için diğer External ile aynı Network'ten verdiğimize dikkat ediyoruz. <br>
          Çünkü biz internete fizikselden çıkıyoruz ve fizikselden internete çıkabilen bir tane Network'ümüz var. <br>
          Bu noktadan sonra Gateway bilgisi giriyoruz fakat aynı Network'te olduğu için aynı Gateway'i birden fazla vermiş olacağız. <br>
          Eğer verirsek, bu bize Multiple Gateway hatası olarak geri dönecek. <br>
          O sebeple şuanda Gateway vermiyoruz bunu başka bir yöntem ile çözeceğiz. <br>
          Bunun sebebini şöyle hayal edebiliriz; <br>
          Bu ikinci hattı kurmamızın sebebi diğerinin Offline olmasına karşın bir önlemdi, bu bağlamda birinin hattı koptuğu anda diğerinden çalışmasını bekliyoruz fakat bu hattın üzerinde Gateway bilgisi yok ise zaten o hat Network'ten çıkamaz anlamına geliyor. <br>
          Bunu çözmenin yöntemi Uplink Balancing'tir.
        </p>

        <h6>Uplink Balacing</h6>
        <p>
          Hizmeti devreye alıyoruz. <br>
          Active Interface ve Standby Interface'leri tanımlayabileceğimiz iki farklı bölüm görürüz. <br>
          Önceden sahip olduğumuz ana hattımızı Active'e tanımlarız, sonradan eklediğimiz ikinci hattı da Standby'a tanımlarız. <br>
          Bu konumda iki hattı da Active'e alırsak, Bandwith'imizi genişletmiş oluruz yani iki hat aynı anda çalışmaya başlar. <br>
          Fakat bizim senaryomuz yedekli çalışmak üzerine olduğu için yukarıdaki gibi yapıyoruz. <br>
          Bu noktada Apply'a basarak yaptığımız tanımlamaları devreye alıyoruz. <br>
          Tekrar Interfaces sekmesine döndüğümüzde yeni eklediğimiz Interface'in Down olduğunu görürüz, çünkü ana hattımız devrede ve sağlıklı bir şekilde çalışıyor. <br>
          Bu noktada ikinci Interface'e girip Gateway verirsek, herhangi bir hata almaz. <br>
          Çünkü zaten bu hat Down durumda kalacak, çalışma koşulu Uplink olduğu diğer Interface'in Down olması. <br>
          Yani birinden biri zaten her zaman Down pozisyonda bekliyor olacak. <br>
          Eğer Dashboard sekmesine gidersek, Interface'lerin tamamını bu bölümde görebiliriz ve son eklediğimiz Interface'in Standby'da beklediğini görebiliriz. <br>
          Şuanda External'ı kapattığımız anda Standby durumda olan Interface anında devreye girer.
        </p>

        <h5>Quality of Service (QoS)</h5>
        <p> 
          Protokol bazında bant genişliğine sınırlamalar uygulayabileceğimiz konumdur. <br>
          Örneğin FTP protoklü ile transferlerde bant genişliğinini %30'unu kullanmak isteyebiliriz. <br>
          Çünkü FTP zaten web üzerinden çok yüksek kapasitede veri aktarımını sağlayan bir protokoldür. <br>
          Bir anda 100'lerce GB'lık bir veri trafiği ile karşılaşmamak için bu tarz bir sınırlandırma yapmak önemlidir.
        </p>

        <h6>QoS uygulamak</h6>
        <p>
          Bunun için iki adımlı bir işlem uygulamalıyız. <br>
          Traffic Selector sekmesine gidiyoruz. <br>
          New Traffic Selector diyerek yeni bir tanım yapıyoruz. <br>
          Öncelikle Bandwith sınırlamasını hangi protokole uygulayacağımızı seçeriz. <br>
          Source ve Destination'larını nereden nereye gidiliyorsa şeklinde düşünerek Service'te de örneğin FTP'yi seçerek bir tanımlama yaparız. <br>
          Save dediğimiz de örneğin Internal'dan Any'e FTP ile gidiliyorsa şeklinde bir tanımlama yapmış oluruz. <br>
          Bu noktada henüz bir kısıt belirtmemiş oluruz, sadece kuralı yazabilmemiz için bir tanımlamaya yapmış olduk. 
        </p>

        <p>
          Tanımlamayı yaptıktan sonra; Download Throttling sekmesine giderek New Download Throttling'e tıklarız. <br>
          Traffic Selectors'te demin oluşturduğumuz tanımı işaretleriz. <br>
          Bir isim veririz ve limit'ini kbit/s şeklinde bir değer atayarak verebiliriz. <br>
          Eğer Limit Shared seçilirse, toplamda belirtilen limit kadar kullanılabilir. <br>
          Eğer Each Source Address seçilirse, her bir Client için bu belirtilen limit uygulanabilir ve her bir Client o Limitte kullanım yapabilir. <br>
          Yani Shared dersek, o anda 100 kişi de kullansa, 1 kişi de kullansa aynı limiti kullanır. <br> 
          Bunu Save'lediğimiz durumda, burada Limit'e hangi değeri atadıysak artık bu protokol o değerin üzerinde bir Bandwith'i kullanamaz. <br>
          Yani eğer 100 mbit/s Download hızımız olsa bile bu protokolü internal'dan any'e olan yöndeki trafiklerde artık örneğin 1024 kbit/s(1 mbit/s) kullanabileceğiz.
        </p>

        <p>
          Bound to Interface seçeneği ile istediğimiz Interface'e ayrı ayrı bir tanımlama yapıp, kuralları ona göre çalıştırabiliriz.
        </p>

        <h5>Static Routing</h5>
        <p>
          Bu konumda Firewall'a yeni Routing'ler yazabiliriz. <br>
          Peki bunu neden yapmak isteyebiliriz? <br>
          Örneğin Client'leri belli bir Network'e yönlendirmek istiyorsak ve bunu belli bir Interface üzerinden yapmak istiyorsak, bu durumda Static Routing yapabiliriz. <br>
          Bu konumda New Static Router'ı seçer ve Add Network Definition diyerek gidilmek istenen Network'u tanımlarız ve o Network'e erişimi olan Interface'ı seçeriz.
        </p>

        <h5>Dynamic Routing(OSPF)</h5>
        <p>
          Firewall'ın dışını yani internet tarafını düşünecek olursak ve burada başka bir Router olduğunu düşünürsek ki her zaman öyledir fakat bu Router'ın da bizim olduğunu düşünelim, bu durumda; o Routing Table'ın bu Firewall'a gelmesini istiyorsak, bu konumdan OSPF'i aktif hale getirmeliyiz. <br>
          Tabiki karşıdaki Router'ın da aynı şekilde OSPF'e aktif hale getirmiş durumda olması gerekiyor. <br>
          Tabiki bunu yapabilmek için karşıdaki Router'ın hangi Area'da olduğunu girmemiz gerekiyor. <br>
          Ayrıca o Area'ya bizim karşı taraftaki Router'ın IP'sini de bilmemiz gerekiyor ki bir OSPF Area tanımlaması yapabilelim. <br>
          Bu tanımlayı yaptıktan sonra OSPF'i devreye alabiliriz.
        </p>

        <h5>Border Gateway Protocol</h5>
        <p>
          Bu kursta bahsedilmedi fakat bu da bir Dynamic Routing Protocol'dür.
        </p>

        <h5>Multicast Routing (PIM-SM)</h5>
        <p>
          Eğer cihazlarımız Multicast Routing'i destekliyorsa, kendi aralarında Multicast üzerinden yine Dynamic Routing yapabilirler. <br>
        </p>

        <p>
          Kısaca biz çok büyük oranda ya Static Routing kullanırız ya da OSPF Dynamic Routing kullanırız. <br>
          Bunu dışındakilerin kullanım sıklığı düşüktür.
        </p>

        <hr>

        <h4>Network Services</h4>

        <h5>DNS</h5>
        <h6>Global</h6>
        <p>
          Bu Firewall DNS hizmetini hangi Network'lere versin? <br>
          Global sekmesinde hangi Network'lere hizmet verdiğini görüntüleriz. <br>
          Default'ta Internal olduğunu görebiliriz. <br>
          Bu şu demektir; İçeriden herhangi bir Client DNS'e ulaştığında sadece ona hizmet verecek demektir. <br>
          Dışarıdan birisi bu Firewall'ı DNS olarak gösterirse eğer, bu DNS hizmet veremeyeceğini söyler. <br>
          Eğer bu konumda Any ya da External gibi bir Network tanımlamasını bildirirsek, bu durumda bu DNS artık dışarıya da hizmet verebilmeye başlar. <br>
        </p>

        <p>
          Global sekmesinin en altında Flust Resolver Cache Now seçeneği vardır. <br>
          Bu buton Firewall üzerinde çalışan DNS'in Cache'ini temizler.
        </p>

        <h6>Forwarders</h6>
        <p>
          Sonuç olarak bu Firewall aslında bir DNS Server değil yani bir isim ya da IP çözemez aslında. <br>
          Dolayısıyla bu Firewall'ın bir DNS'e Forward edilmesi gerekiyor. <br>
          Yani yapılan sorguları bir DNS'e yönlendirmesi gerekiyor. <br>
          Bu konumda bu yönlendirmeyi hangi DNS'e yapmak istiyorsak, onu bildiririz.
        </p>

        <h6>Request Route</h6>
        <p>
          DNS üzerindeki Conditional Forwarders'a tekabül eder. <br>
          Örneğin; <br>
          Domain: sirket3.com
          Target servers: network2(IP:10.3.34.222)
          -> Bu şu demek; sirket3.com ile ilgili bir sorgu gelirse başka yerde arama direkt olarak network2'ye git. <br>
          Fakat bu durumda Target Server eğer başka bir Network'te ise ki öyle olması mantıklıdır. <br>
          Bu durumda network2 de başka bir Firewall olabilir ve eğer öyleyse o Firewall üzerindeki Network Servis ayarlarından DNS'in ya External Network'lere ya da direkt olarak bizim Network'ümüze izin veriyor olması gerekir. <br>
          Yoksa bu DNS yukarıda yapılan yönlendirmeye cevap vermez.
        </p>

        <h6>Static Entries</h6>
        <p>
          Bir DNS Host kaydı girebilmemizi sağlayan konumdur. <br>
          Örneğin PC0'ın Host kaydını girmek istiyorsak, Type'ını Host seçer adını ve IP'sini girerek DNS'te bu kaydo oluşturabiliriz.
        </p>

        <h6>DynDNS</h6>
        <p>
          dk 34
        </p>


        
        
        <hr>
        
        <div class="text-center container p-3 bg-script">
          <div class="d-flex justify-content-evenly navigation">
            <a href="16-04-2023.html" class="bg-script">16.04.2023</a>
            <a href="../May-05-2023/05-06-2023.html" class="bg-script">05.05.2023</a>
          </div>
        </div>
        

    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>
  </body>
</html>