<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>29.04.2023</title>
    <link rel="icon" type="image/x-icon" href="../eg_favicon.JPG">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@200;300;400;600&display=swap" rel="stylesheet"> 
    <style>
      body {
        font-family: 'Source Code Pro', monospace;
        font-size: 14px;
        color: #e2e3e7;
        background-color: #232529;
        /*
        e2e3e7
        c4c7cf
        868d9a
        696e79
        41454c
        35383f
        292c31
        232529

        31333a
        */
      }

      h1 {
        text-align: center;
      }

      h1 > a {
        color: rgb(139, 233, 253);
      }

      h1, h2, h3, h4, h5, h6 {
        color: rgb(139, 233, 253);
      }

      a{
        text-decoration: none;
      }

      a:hover {
        color: #e2e3e7;
      }

      .container {
        max-width: 800px;
        border: 1px solid rgb(139, 233, 253);
        border-radius: 10px;
      }

      .bg-script {
        color: rgb(139, 233, 253);
        background-color: #31333a;
        padding: 20px;
        border: 1px solid rgb(139, 233, 253);
        border-radius: 10px;
        text-align: start;
        font-size: 15px;
        line-height: normal;
      }

      .navigation > a:hover {
        color: #31333a;
        background-color: rgb(139, 233, 253);
      }

    </style>
  </head>
  <body>
    <div class="container p-4 mt-2 mb-5">
        <h1><a href="../index.html" class="display-4">29.04.2023</a></h1>
        
        <hr>

        <h2>SOPHOS Firewall Arayüzü</h2>
        <p class="bg-script">
          > SOPHOS Arayüz; https://192.168.1.2:4444 <br>
        </p>

        <hr>

        <h4>Definations & Users</h4>
        <p>
          Bu başlık kendi içinde 7 başlığa daha kırılıyor.
        </p>

        <h5>Network Definations</h5>
        <p>
          Defination and Users önceden tarif edilmiş olan her şeyin bulunduğu konumdur. <br>
          Herhangi bir kural yazmadan önce ya da kural uygulanmadan önce mutlaka burada onun nereye uygulanacağı ve ne olduğu tarif edilmiş olmalıdır. <br>
          Örneğin; <br>
          Any -> IP'si ne olursa olsun demektir, iç Network dış Network fark etmez. <br>
          Built in olarak bu konumda Any'nin tarif edilmiş olduğunu zaten görüyoruz. <br>
          Buna benzer şekilde farklı farklı Built-in Defination'lar olduğunu da bu konumda görebiliriz. <br>
          Bazı durumlarda, mesela DNS'i Forward ettiğimizde otomatik olarak burada bazı tariflerin açıldığını da görürüz. <br>
          Örneğin Domain Controller makinemizin üzerindeki DNS'i bu Firewall'dan Forward ettiysek otomatik olarak Domain Controller'in bu konumda tarif edildiğini görebiliriz. <br>
          Yani örneğin; Domain Controller'ımızın adı DC01 ve IP'si 192.168.1.2 ise bunun aynen bu şekilde bu konumda tarif edildiğini görürüz. <br>
          Buna benzer şekilde External Network'ü ve Direkt Interface'ini, aynı şekilde Internal Network'ü ve Interface'ini de otoamtik olarak tarif eder. <br>
          Çünkü Firewall yaptığımız bu makinenin de üzerinde Interface'ler bulunuyor, bu bilgiyi direkt olarak kendi üzerinden okuyup, burada tarif edebiliyor. <br>
          Tabiki bulunduğu Network'lerin Broadcast ve Network ID'lerini de tarif eder.
        </p>
       
        <h5>Service Definations</h5>
        <p>
          Bu konumda da DNS, FTP, DHCP, Email Messaging vs. gibi servislerin tanımının yapıldığını görüyoruz. <br>
          Daha sonradan bir hizmet tanımlamak istediğimiz durumda bu konuma gelerek ekle butonu ile direkt olarak tanımlama yapabiliriz. <br>
          Built-in olarak standart verilen hizmetlerin zaten tanımlandığını görüyoruz. <br><br>

          Fakat bir "Service Defination'ın" nasıl olduğuna örnek verecek olursak, şunlardan bahsedebiliriz; <br>
        </p>

        <ol>
          <li>Her Service'in bir ismi vardır;</li>
          <span>Örneğin; DNS. </span>
          <li>Her Service'in tanımlama tipi vardır;</li>
          <span>DNS için; TCP/UDP, yani DNS'in TCP/UDP protokolleriyle çalıştığını tanımlayan madde.</span>
          <li>Her Service'in tanımlama Port'u vardır;</li>
          <span>DNS için; 53</span>
          <li>Her Service'in kaynak Port'u vardır;</li>
          <span>DNS için; 1:65535</span>
        </ol>

        <p>
          Özetle DNS TCP/UDP protokolleriyle 53 numaralı Port'tan dinleme yapabilme marifetine sahip olan bir Service olduğu için tanımlaması tam olarak bu şekilde yapılmıştır. <br>
          Diğer Service'leri tanımlarken onların kullanabildiği Protokol ve Port'lara göre bu maddeler tanımlanır. <br>
          Yani bir Service tanımlamak demek aslında o Service'in Protokollerini ve Port'ları tanımlamak demektir.
        </p>
        

        <h5>Time Period Definitions</h5>
        <p>
          Kuralların hangi saat aralıklarında block'lanacaklarının ya da uygulanacaklarının belirlendiği konumdur. <br>
          Built-in olarak Lunch, Time to install updates, weekend gibi zaman aralıklarının tarif edildiğini görüyoruz. <br>
          Örneğiz biz bu konumdan şirketimizin mesai saatlerini tarif eden bir tanımlama yapabiliriz. <br>
          Fakat tabiki bu konumda sadece tanımlama yapıyoruz, yani tarif ediyoruz. <br>
          Herhangi bir kural yazılmış durumda değil, daha sonradan bu tarifleri kullanarak kurallar tanımlayabileceğiz.
        </p>

        <h5>Users and Groups</h5>
        <p>
          Bu konumda varolan User'larımızın tarifi yapılır. <br>
          Kural yazmak istediğimiz User ve Group'ları bu konumdan tanımlıyoruz. <br>
          Burada Built-in olarak Admin hesabını görürüz. <br>
          Bu hesap Firewall üzerindeki en yetkili hesaptır. <br>
          SuperAdmins grubuna üyedir. <br>
          Bu gruba hangi User'ı üye edersek artık o User da Firewall üzerinde tam yetkiye sahip olur. <br>
          Ayrıca bu konumda Active Directory üzerinden Authentication'ı yapılan User'lar da listelenirler.
        </p>

        <h5>Client Authentication</h5>
        <p>
          User Portal'ımıza hangi Client'ler ve hangi User ya da Group'lar erişebilsin bunun tanımlamasını yaptığımız konumdur. <br>
          Bu konumda Allowed Networks bölümüne örneğin Internal'ı verdiğimizde Network'ümüzden IP alan tüm cihazlar User Portal'a erişebilir anlamına gelir. <br>
          Aynı şekilde Allowed Users and Groups'a eklediğimiz her bir User ya da Group da User Portal'a erişebilir. <br>
          Bu konumda Network'ü ya da direkt olarak cihazları ve User ya da Group'ları tanımladan atlarsak User Portal'a erişimi açsak bile Client Authentication programı erişebilir durumda olmaz. <br>
          Bu sebepte önce burada tanımlama yapılmalı daha sonra Portal aktif hale getirilmeli, aksi durumda zaten Portal'a erişenler bomboş bir sayfa ile karşılaşırlar. <br>
          Client Authentication Program kullanıcıların her defasında giriş yapmasını engelleyen bir Script'tir. <br>
          Program arkaplanda otomatik olarak id şifreyi girer ve Authentication'ı sağlar. <br>
          Global sekmesinde Authentication yapılan hesapların listelendiğini yani yapılan etkileşimi görebiliriz.
        </p>

        <h5>AWS Profiles</h5>
        <p>
          Amazon Web Service, Windows Azure Service'in rakibidir ve dünya genelinde daha fazla kullanılır. <br>
          Sanallaştırma ya da herhangi bir Network Service hizmetini veren bir hizmettir. <br>
          Eğer AWS'den bir hizmet alıyorsak ve Amazon ile birlikte çalışacağımız bir senaryomuz var ise Sophos'a bu ilişkimizi bildirmemiz gerekiyor. <br>
          Bunun içinde AWS Profiles kısmından Add Profile diyerek, Erişim Anahtarımızı giriyoruz. <br>
          Özetle bu tanımlama; AWS üzerinde çalışan bir Network'ümüz yani oradan hizmet veren cihazlarımız var ise o cihazların yani Network'ün üzerinde bu Firewall çalıştırılacak anlamına geliyor.
        </p>

        <h5>Authentication Services</h5>
        <p>
          Bu konumda Domain Controller'ımızı tanımlayıp, bu Firewall'u Domain'e ekleyebiliyoruz. <br>
          Ayrıca Single Sign-On yapabiliyoruz. <br>
          Single Sign-On, Firewall'a Active Directory üzerinden Authentication yapan hesapların Log-on olmasını sağlar. <br>
          Yani sadece admin hesabının değil Domain Admin'in ve Domain'deki diğer hesapların da Log-on olabilmesi sağlanır. <br>
          Ancak admin yetkisi sadece SuperAdmins grubuna üye olan hesaplarda bulunur.
        </p>
        <p>
          Bu ekranda Authentication Cache adında bir bölüm vardır. <br>
          Bu bölümden direkt olarak Authentication Cache silinebilir. <br>
          Hangi durumda bunu kullanmaya ihtiyaç duyabiliriz? <br>
          Örneğin bir User'ın Password'unu değiştirdik, User Log-on olmak istediğinde Firewall o User'ın eski Password'una sahip olabilir. <br>
          Çünkü bu alan bir Cache yani önbellek, dinamik olarak anında değişebilen bir hafıza bölgesi değil. <br>
          O anda bilgi henüz güncellenmemiş olabilir ve bu durumda Authentication sağlanamaz ve kullanıcı Log-on olamaz. <br>
          Bu noktada Cache'i temizleyerek yeni bilginin alınmasını sağlayabiliriz. <br>
          Authentication problemlerinde önce tarih ve saat ayarları kontrol edilmelidir. <br>
          Giriş yapılan cihaz ile Authentication'ı yapacak olan cihaz arasında zaman farkı olmamalıdır. <br>
          Bu tüm Authentication yapılan alanlarda geçerli olan bir durumdur.
        </p>

        <hr>

        <h4>Interfaces and Routing</h4>

        <h5>Interfaces</h5>
        <p>
          Firewall'ın üzerindeki Interface'leri yani Ethernet Port'larını görürüz. <br>
          Bu konumda bir Interface'in devre dışı kalması durumunda diğer bir Interface'ten çalışmaya devam etmesini sağlayacak ayarlar yapılabilir. <br>
          Server üzerinde NIC Teaming adıverilen bir teknolojinin benzeri direkt Firewall üzerinden de uygulanabilir. <br>
          Firewall'lar üzerinde çalıştıkları Network'ler için Gateway olduklarından dolayı o Network'ten yapılan tüm çıkışlar ve girişler Firewall'ın External Interface'inden olacağı anlamına gelir. <br>
          Bu durumda eğer External Interface kaybedilirse, o Network'ün dış dünya ile iletişimi yani internete olan bağlantısı kaybedilir. <br>
          Bunun gibi durumlar için önlem amaçlı olarak ISP'lerden bir hat daha alınabilir. <br>
          Farklı bir ISP'den yine fiber(fakat aynı kabloları kullanmayan) ya da aynı ISP'den farklı bir teknoloji(örneğin vDSL veya GSM) şeklinde yeni bir yedek hat alınabilir. <br>
          Yedek olarak alınan bu hattı Stand-by durumda bekletebiliriz ve ana hattımızda bir kesinti olması durumunda anında devreye girerek durumu anlık olarak kurtarmasını sağlayabiliriz. <br>
        </p>

        <h6>External Interface'lerden birisinin Offline olmasına önlem olarak yapılabilecekler</h6>
        <p>
          Interface sekmesinde Hardware bölümünde makinenin üzerinde Interface'ler görüntülenir. <br>
          Yeni bir External Interface ekliyoruz. <br>
          Kartı taktıktan sonra bu ekranda görüntüleyemiyorsak, makineyi Restart'larız. <br>
          Restart'ladıktan sonra listeleniyor olması gerekiyor. <br>
          Bu noktada Interfaces sekmesinde yeni eklediğimiz Interface'i göremeyiz. <br>
          Çünkü henüz bu Interface'i henüz tanımlamadık. <br>
          Bunun için New Interface'e tıklıyoruz. <br>
          Hardware seçeneğinden eklediğimiz Interface'i seçeriz. <br>
          Type kısmından Ethernet'i seçiyoruz. <br>
          Buradaki Type ile bu hattı hangi cinsten aldıysak onu belirtiyoruz. <br>
          Örneğin 3G olabilir ya da DSK olabilir vs. <br>
          Eğer GSM aldıysak 3G'yi seçebiliriz gibi. <br>
          Biz sanalda bunu Ethernet'e bağlayarak kendi sahip olduğumuz fiziksel External'a çıkacağımız için Ethernet'i seçiyoruz ki uygulayabilelim. <br>
          Özetle ne tür bir internet hattı aldıysak onu bu Interface ile eşleştiriyoruz ya da başka bir değişle onun üzerine tanımlıyoruz. <br>
          Bu Interface'e bir IP atıyoruz, sanalda yaptığımız için yani simüle ettiğimiz için diğer External ile aynı Network'ten verdiğimize dikkat ediyoruz. <br>
          Çünkü biz internete fizikselden çıkıyoruz ve fizikselden internete çıkabilen bir tane Network'ümüz var. <br>
          Bu noktadan sonra Gateway bilgisi giriyoruz fakat aynı Network'te olduğu için aynı Gateway'i birden fazla vermiş olacağız. <br>
          Eğer verirsek, bu bize Multiple Gateway hatası olarak geri dönecek. <br>
          O sebeple şuanda Gateway vermiyoruz bunu başka bir yöntem ile çözeceğiz. <br>
          Bunun sebebini şöyle hayal edebiliriz; <br>
          Bu ikinci hattı kurmamızın sebebi diğerinin Offline olmasına karşın bir önlemdi, bu bağlamda birinin hattı koptuğu anda diğerinden çalışmasını bekliyoruz fakat bu hattın üzerinde Gateway bilgisi yok ise zaten o hat Network'ten çıkamaz anlamına geliyor. <br>
          Bunu çözmenin yöntemi Uplink Balancing'tir.
        </p>

        <h6>Uplink Balacing</h6>
        <p>
          Hizmeti devreye alıyoruz. <br>
          Active Interface ve Standby Interface'leri tanımlayabileceğimiz iki farklı bölüm görürüz. <br>
          Önceden sahip olduğumuz ana hattımızı Active'e tanımlarız, sonradan eklediğimiz ikinci hattı da Standby'a tanımlarız. <br>
          Bu konumda iki hattı da Active'e alırsak, Bandwith'imizi genişletmiş oluruz yani iki hat aynı anda çalışmaya başlar. <br>
          Fakat bizim senaryomuz yedekli çalışmak üzerine olduğu için yukarıdaki gibi yapıyoruz. <br>
          Bu noktada Apply'a basarak yaptığımız tanımlamaları devreye alıyoruz. <br>
          Tekrar Interfaces sekmesine döndüğümüzde yeni eklediğimiz Interface'in Down olduğunu görürüz, çünkü ana hattımız devrede ve sağlıklı bir şekilde çalışıyor. <br>
          Bu noktada ikinci Interface'e girip Gateway verirsek, herhangi bir hata almaz. <br>
          Çünkü zaten bu hat Down durumda kalacak, çalışma koşulu Uplink olduğu diğer Interface'in Down olması. <br>
          Yani birinden biri zaten her zaman Down pozisyonda bekliyor olacak. <br>
          Eğer Dashboard sekmesine gidersek, Interface'lerin tamamını bu bölümde görebiliriz ve son eklediğimiz Interface'in Standby'da beklediğini görebiliriz. <br>
          Şuanda External'ı kapattığımız anda Standby durumda olan Interface anında devreye girer.
        </p>

        <h5>Quality of Service (QoS)</h5>
        <p> 
          Protokol bazında bant genişliğine sınırlamalar uygulayabileceğimiz konumdur. <br>
          Örneğin FTP protoklü ile transferlerde bant genişliğinini %30'unu kullanmak isteyebiliriz. <br>
          Çünkü FTP zaten web üzerinden çok yüksek kapasitede veri aktarımını sağlayan bir protokoldür. <br>
          Bir anda 100'lerce GB'lık bir veri trafiği ile karşılaşmamak için bu tarz bir sınırlandırma yapmak önemlidir.
        </p>

        <h6>QoS uygulamak</h6>
        <p>
          Bunun için iki adımlı bir işlem uygulamalıyız. <br>
          Traffic Selector sekmesine gidiyoruz. <br>
          New Traffic Selector diyerek yeni bir tanım yapıyoruz. <br>
          Öncelikle Bandwith sınırlamasını hangi protokole uygulayacağımızı seçeriz. <br>
          Source ve Destination'larını nereden nereye gidiliyorsa şeklinde düşünerek Service'te de örneğin FTP'yi seçerek bir tanımlama yaparız. <br>
          Save dediğimiz de örneğin Internal'dan Any'e FTP ile gidiliyorsa şeklinde bir tanımlama yapmış oluruz. <br>
          Bu noktada henüz bir kısıt belirtmemiş oluruz, sadece kuralı yazabilmemiz için bir tanımlamaya yapmış olduk. 
        </p>

        <p>
          Tanımlamayı yaptıktan sonra; Download Throttling sekmesine giderek New Download Throttling'e tıklarız. <br>
          Traffic Selectors'te demin oluşturduğumuz tanımı işaretleriz. <br>
          Bir isim veririz ve limit'ini kbit/s şeklinde bir değer atayarak verebiliriz. <br>
          Eğer Limit Shared seçilirse, toplamda belirtilen limit kadar kullanılabilir. <br>
          Eğer Each Source Address seçilirse, her bir Client için bu belirtilen limit uygulanabilir ve her bir Client o Limitte kullanım yapabilir. <br>
          Yani Shared dersek, o anda 100 kişi de kullansa, 1 kişi de kullansa aynı limiti kullanır. <br> 
          Bunu Save'lediğimiz durumda, burada Limit'e hangi değeri atadıysak artık bu protokol o değerin üzerinde bir Bandwith'i kullanamaz. <br>
          Yani eğer 100 mbit/s Download hızımız olsa bile bu protokolü internal'dan any'e olan yöndeki trafiklerde artık örneğin 1024 kbit/s(1 mbit/s) kullanabileceğiz.
        </p>

        <p>
          Bound to Interface seçeneği ile istediğimiz Interface'e ayrı ayrı bir tanımlama yapıp, kuralları ona göre çalıştırabiliriz.
        </p>

        <h5>Static Routing</h5>
        <p>
          Bu konumda Firewall'a yeni Routing'ler yazabiliriz. <br>
          Peki bunu neden yapmak isteyebiliriz? <br>
          Örneğin Client'leri belli bir Network'e yönlendirmek istiyorsak ve bunu belli bir Interface üzerinden yapmak istiyorsak, bu durumda Static Routing yapabiliriz. <br>
          Bu konumda New Static Router'ı seçer ve Add Network Definition diyerek gidilmek istenen Network'u tanımlarız ve o Network'e erişimi olan Interface'ı seçeriz.
        </p>

        <h5>Dynamic Routing(OSPF)</h5>
        <p>
          Firewall'ın dışını yani internet tarafını düşünecek olursak ve burada başka bir Router olduğunu düşünürsek ki her zaman öyledir fakat bu Router'ın da bizim olduğunu düşünelim, bu durumda; o Routing Table'ın bu Firewall'a gelmesini istiyorsak, bu konumdan OSPF'i aktif hale getirmeliyiz. <br>
          Tabiki karşıdaki Router'ın da aynı şekilde OSPF'e aktif hale getirmiş durumda olması gerekiyor. <br>
          Tabiki bunu yapabilmek için karşıdaki Router'ın hangi Area'da olduğunu girmemiz gerekiyor. <br>
          Ayrıca o Area'ya bizim karşı taraftaki Router'ın IP'sini de bilmemiz gerekiyor ki bir OSPF Area tanımlaması yapabilelim. <br>
          Bu tanımlayı yaptıktan sonra OSPF'i devreye alabiliriz.
        </p>

        <h5>Border Gateway Protocol</h5>
        <p>
          Bu kursta bahsedilmedi fakat bu da bir Dynamic Routing Protocol'dür.
        </p>

        <h5>Multicast Routing (PIM-SM)</h5>
        <p>
          Eğer cihazlarımız Multicast Routing'i destekliyorsa, kendi aralarında Multicast üzerinden yine Dynamic Routing yapabilirler. <br>
        </p>

        <p>
          Kısaca biz çok büyük oranda ya Static Routing kullanırız ya da OSPF Dynamic Routing kullanırız. <br>
          Bunu dışındakilerin kullanım sıklığı düşüktür.
        </p>

        <hr>

        <h4>Network Services</h4>

        <h5>DNS</h5>
        <h6>Global</h6>
        <p>
          Bu Firewall DNS hizmetini hangi Network'lere versin? <br>
          Global sekmesinde hangi Network'lere hizmet verdiğini görüntüleriz. <br>
          Default'ta Internal olduğunu görebiliriz. <br>
          Bu şu demektir; İçeriden herhangi bir Client DNS'e ulaştığında sadece ona hizmet verecek demektir. <br>
          Dışarıdan birisi bu Firewall'ı DNS olarak gösterirse eğer, bu DNS hizmet veremeyeceğini söyler. <br>
          Eğer bu konumda Any ya da External gibi bir Network tanımlamasını bildirirsek, bu durumda bu DNS artık dışarıya da hizmet verebilmeye başlar. <br>
        </p>

        <p>
          Global sekmesinin en altında Flust Resolver Cache Now seçeneği vardır. <br>
          Bu buton Firewall üzerinde çalışan DNS'in Cache'ini temizler.
        </p>

        <h6>Forwarders</h6>
        <p>
          Sonuç olarak bu Firewall aslında bir DNS Server değil yani bir isim ya da IP çözemez aslında. <br>
          Dolayısıyla bu Firewall'ın bir DNS'e Forward edilmesi gerekiyor. <br>
          Yani yapılan sorguları bir DNS'e yönlendirmesi gerekiyor. <br>
          Bu konumda bu yönlendirmeyi hangi DNS'e yapmak istiyorsak, onu bildiririz.
        </p>

        <h6>Request Route</h6>
        <p>
          DNS üzerindeki Conditional Forwarders'a tekabül eder. <br>
          Örneğin; <br>
          Domain: sirket3.com
          Target servers: network2(IP:10.3.34.222)
          -> Bu şu demek; sirket3.com ile ilgili bir sorgu gelirse başka yerde arama direkt olarak network2'ye git. <br>
          Fakat bu durumda Target Server eğer başka bir Network'te ise ki öyle olması mantıklıdır. <br>
          Bu durumda network2 de başka bir Firewall olabilir ve eğer öyleyse o Firewall üzerindeki Network Servis ayarlarından DNS'in ya External Network'lere ya da direkt olarak bizim Network'ümüze izin veriyor olması gerekir. <br>
          Yoksa bu DNS yukarıda yapılan yönlendirmeye cevap vermez.
        </p>

        <h6>Static Entries</h6>
        <p>
          Bir DNS Host kaydı girebilmemizi sağlayan konumdur. <br>
          Örneğin PC0'ın Host kaydını girmek istiyorsak, Type'ını Host seçer adını ve IP'sini girerek DNS'te bu kaydo oluşturabiliriz.
        </p>

        <h6>DynDNS</h6>
        <p>
          Dynamic DNS anlamına gelir. <br>
          Örneğin evlerimizde internete çıkmazı sağlayan bir modemimiz vardır. <br>
          Eğer dış bacak için bir Static IP almadıysak, dinamik olarak devamlı olarak IP'miz aslında değişir. <br>
          Örnek olarak bir PC aldık ve Web Hoting yapıyoruz ya da FTP Server kurduk dosya paylaşıyoruz. <br>
          İçime gerekli dosyaları koyduk ve istiyorki dünyanın her yerinden bu Server'a bağlanıp dosyalarımızı görüntüleyebilelim. <br>
          Böyle bir durumda sıkıntımız şudur; Server'a bağlanmak için VPN kullanabiliriz. <br>
          Bu bir seçenektir, yani ayrı bir çözümdür. <br>
          Fakat bunu yapmadık, gittik direkt Web Tarayıcıya Domain'in ismini yazdık vs. isim çözümlemesi gerekiyor. <br>
          Yani bunu yaptığımızda gerçekleşecek olan şey isim çözümlemesi. <br>
          Girdiğimiz bu isme karşılık gelen IP bizim modemmizimin dış bacağının IP'si olmalıdır. <br>
          Fakat Domain aldıysak bu sorun değil çünkü o IP artık değişmez fakat bu bahsettiğimiz senaryoda dış bacağın IP'sinin değişmeyeceğinin garantisi yok. <br>
          Çünkü modem bize IP'yi 24 saatliğine kiralar. <br>
          Bu durumda içerideki makineye bir uygulamaya kuruyoruz. <br>
          O uygulama modemin IP'si değiştiğinde, Dynamic DNS hizmeti veren firmaya gidiyor ve altalanda alınan yeni IP'yi yazıyor. <br>
          Yani aslında DynDNS bir hizmettir ve bu hizmeti veren firmalar vardır. <br>
          Özetle Dynamic DNS; IP'si sürekli değişen Server'ların Host kayıtlarını otomatik olarak Update edebilen bir hizmettir.
        </p>
        <p>
          Uygulamak için New DynDNS'e tıklarız. <br>
          Type'a tıklarsak Sophos'un bize önerdiği bu hizmeti veren firmaları gösterir. <br>
          Buradan bu şekilde seçer seçmez bağlanamayız. <br>
          Buradan seçtiğimiz firmaya gidip, o firmadan önce hizmeti satın almalıyız. <br>
          O, hizmete nasıl bağlanacağımızı bildiren bilgileri verir. <br>
          Username, Password gibi bilgileri o hizmeti veren siteden alırız.
        </p>
        <p>
          Dynamic DNS genelde küçük işletme ya da evlerde kullanmayı tercih edeceğimiz bir uygulamadır. <br>
          Çünkü zaten IP'nin otomatik olarak değişiyor olması professiyonel bir ortamdan uzaklaşmak anlamına gelir.
        </p>

        <h5>DHCP</h5>
        <p>
          Firewall'lar DHCP Server'lar gibi davranabilirler. <br>
          Çünkü sonuç olarak bu Firewall artık zaten bir Router gibi yani Internal'daki tüm cihazların zaten bu makineye erişimi var o sebeple bu hizmeti de verebilmesi de gayet normal bir durum. <br>
        </p>

        <h6>Servers</h6>
        <p>
          Static IP'ler için belli sayıda ayırdığımız IP'nin üstüne bir değer girerek IP dağıtmasını sağlayabiliriz. <br>
          Çünkü örnek verecek olursak 1-10 arasındaki IP'leri Static olarak bazı Server'lara atamış olabiliriz. <br>
          Fakat bu konumda 192.168.0.1 şeklinde başlatırsak bu IP'leri yeniden dağıtır.
        </p>
        <p class="bg-script">
          New DHCP Server <br>
          Interface: Internal
          Range Start: 192.168.0.50
          Range End: 192.168.0.254
        </p>
        <p>
          Yukarıdaki şekilde tanımlayıp Save edersek, içeriye bir makine kurduğumuz durumda 50'den itibaren otomatik olarak Firewall'dan IP aldığını görebiliriz. <br>
        </p>

        <p>
          Hatırlatma; <br>
          DHCP Broadcast'leri Router'lardan geçmezler. <br>
          Doğal olarak Firewall'lar da DHCP Boradcast'leri geçizmeler.
        </p>

        <p>
          İki farklı Network'ün ve aralarında bir Firewall'un bulunduğunu düşünelim. <br>
          Bir Network'te DHCP Server bulunsun ve kendi Network'ündekiler o DHCP'den IP alsınlar. <br>
          Fakat bu DHCP'nin ikinci Network'te de IP dağıtmasını isteyelim. <br>
          Bu durumda Router'lardan DHCP Broadcast'ler geçmeyeceği için Client'ler bu DHCP'den IP alamazlar. <br>
        </p>

        <p>
          Buradaki sorunu çözmenin 3 farklı yöntemi vardır; <br>
          1- İkinci Network'e de bir tane DHCP Server kurulabilir fakat bu merkezi bir DHCP Server çözümü olmaz. <br>
          2- Firewall'a gideriz, DHCP hizmetini açarız ve External'a IP dağıtmasını sağlarız. Bunu yaptığımızda artık diğer DHCP'ye de ihtiyaç kalmaz direkt olarak sadece Firewall üzerinden IP dağıtabiliriz. <br>
          3- Hem Firewall IP dağıtmasın hem de her Network'te bir tane DHCP Server olmasın diyorsak, "DHCP Relay Agent" adıverilen Service kullanılır.
        </p>

        <h6>Relay</h6>
        <p>
          Eğer Network'lerin merkezinde bir yere, örneğin Firewall'a DHCP Relay Agent kurarsak ve belirtilen Interface'lerden gelen DHCP Broadcast'lerini dinle ve reddetme, Unicast'e çevir ki üzerinden geçebilsin, ardından şu DHCP'ye gönder şeklinde bir konfigürasyon yapmamız gerekiyor. <br>
          Bu ayarı yaptığımız durumda bu Service her bir Client'in DHCP Broadcast'ini alır Unicast'e çevirir ve belirtilen DHCP'ye gönderir. <br>
          DHCP'de de buna göre Scope oluşturulur ve o makineler IP'lerini alırlar. <br>
          Böylede DHCP Server eğer bir Router'ın arkasında ise yine de IP dağıtmaya başlar.
        </p>
        <p>
          Relay sekmesinden ilgili butona basarak bu hizmeti direkt devreye alabiliriz. <br>
          Fakat DHCP hizmetini verecek olan Server belirtilmelidir. <br>
          Interfaces kısmında ise hangi Interface'ten gelen talepleri yönelteceğini belirtiriz. <br>
          Örneğin External Network'ü eklersek, External'dan gelen DHCP Broadcast'leri Unicast'e çevirip yukarıda belirttiğimiz DHCP Server'a gönderirir.
        </p>

        <h6>Static Mappings</h6>
        <p>
          İstediğimiz bir makineye sürekli olarak aynı IP'nin atılmasını bu noktadan sağlayabiliriz. <br>
          DHCP Server'ların üzerindeki IP Reservation'a denk gelir.
        </p>
        <p class="bg-script">
          > Static Mappings
          > New Network Definations
          > Name: PC10(Örneğin)
          > Type: Host
          > IPv4 Address: 192.168.0.24
        </p>
        <p>
          Eğer yukarıdaki şekilde bir kural girersek ilgili makineye sürekli olarak girdiğimiz IP'yi atar.
        </p>

        <h6>IPv4 Lease Table</h6>
        <p>
          Eğer DHCP hizmetini Firewall üzerinden verdiysek, verilen IP'leri hangi makinelere verdiğini ne zaman verdiğini vs bu sekmede listeler.
        </p>

        <h6>NTP</h6>
        <p>
          Network Time Protocol'dür. <br>
          Domain'deki makinelerin saat senkronizasyonu çok önemlidir. <br>
          Bu senkronizasyonu bir NTP Server'a göre de yapabiliriz. <br>
          Eklemek istersek Google'dan NTP Turkey Server'larını araştırıp birisini bu konumdan ekleyebiliriz.
        </p>

        <hr>

        <h4>Network Protection</h4>
        <h5>Firewall</h5>
        <h6>Rules</h6>
        <p>
          Firewall varsayılanda içeriden dışarıya, dışarıdan içeriye kimseyi, hiç bir protokolü vs hiç bir zaman almaz. <br>
          Biz bu istinaları belirtecek kurallar vererek bu geçişlere izin veriyoruz aslında. <br>
          Yani Firewall bizim açtıklarımıza izin verir.
        </p>
        <p>
          Bu bağlamda örnek olarak; içerideki DNS'e 8.8.8.8'e gidiyorsa trafiğe izin ver şeklinde bir kural yazabiliriz;
        </p>
        <p class="bg-script">
          > Network Protection <br>
          > Firewall <br>
          > Position: Bottom(Sıralama) <br>
          > Source: DNS Server <br>
          > Services: DNS <br>
          > Destination: Google DNS Server; 8.8.8.8 <br>
          > Action: Allow -> Trafiğe izin verir. <br>
          > Save <br>
          > Button'dan kural Enable edilir.
        </p>
        <p>
          Burada gördüğümüz tablodaki Position asc bilgisi önemlidir. <br>
          Numara küçükten büyüğe doğru ilerler. <br>
          En küçük numara en yüksek öncelikli kuraldır ve öncelik azalarak, sayı arttıkça devam eder. <br>
          Trafikler her zaman tepeden başlar kontrol yapılarak tüm kurallara ve önceliklerine göre değerlendirip öyle uygulanır. <br>
          Yani en öncelikli kural Internal'dan Any'e DNS Allow veriyorsa, daha altlarda Reject ya da Drop'lasak bile öncelikli kural çalışıtırılacağı için trafik Allow olur.
        </p>

        <p>
          Geçmesini istediğimiz tüm trafikleri tek tek bu şekilde kural yazarak Allow'lamamız gerekiyor. <br>
          Yani hangi Network'ten hangi Network'e ya da Server'a vs gidilmek isteniyorsa bunu dikkatli bir şekilde belirmek gerekiyor.
        </p>

        <h6>Country Blocking</h6>
        <p>
          Veri trafiğini ülke bazında sınırlandırabiliriz. <br>
          Bu Service'i Enable ettiğimizde internetten erişebileceğimiz herhangi bir ülkeye çıkışı veya dönüşü ya da her ikisini birden engelleyebiliriz.
        </p>
        <p>
          To -> Gidiş yönünü yani bizim çıkışımızı engellemek için, <br>
          From -> Dönüş, yani karşı tarafın bize gelmesini engellemek için, <br>
          All -> İki yönlüde trafiği tamamen engellemek için seçebileceğimiz seçeneklerdir.
        </p>
        <p> 
          Burada dikkat etmemiz gereken şey özellikle DNS gibi kritik hizmetleri aldığımız hatları da engellememiş olmaktır. <br>
          Örneğin USA'ya olan trafiği engellersek ve DNS'imizi Google'a Forward etmiş durumdaysak, DNS'imiz çalışmaz 8.8.8.8 DNS'ine erişemez ve isim çözümlemesi yapamaz duruma gelebilir.
        </p>
        <p>
          Özetle hangi konumu engellersek o konumdaki Server'lara erişim olmaz. <br>
          Dolayısıyla o Server'lardan yayımlanan Web Site'lerine vs de erişemeyiz.
        </p>

        <h6>Country Blocking Exceptions</h6>
        <p>
          Örnek olarak bir ülkeyle olan tüm trafiğimizi engellemiş olsak fakat o ülkenin içindeki özellile sadece bir Router'a yani Network ya da Server'a vs erişmek istiyorsak bunu istisna olarak belirtebiliriz.
        </p>
        <p class="bg-script">
          > Network Protection <br>
          > Firewall <br>
          > Add Exception List <br>
          > Countries[Ülke seçilir] <br>
          > For all request: going to these <br>
          -> Host/Network[Gitmek istediğimiz Host/Network seçilir] <br>
          > Using these <br>
          -> Services[Örneğin FTP Service'i ile gitmeyi hariç tutuyoruz]
        </p>

        <h6>ICMP</h6>
        <p>
          Özellikle Ping ve test aşamasında kullanılan bir protokoldür. <br>
          Bu ekranda 3 bölümle karşılaşırız Global ICMP Settings, Ping Settings ve Traceroute Settings.
        </p>

        <h6>Ping Settings</h6>
        <p>
          [+]Gateway is ping visible -> Gateway Ping'lenebilir.<br>
          [+]Ping from gateway -> Gateway'den Ping atılabilir. <br>
          [+]Gateway forwards pings -> Gateway aldığı Ping'i Forward edebilir. <br>
        </p>
        <p>
          Internal'dan Google'a Ping atmak istediğimizde attığımız Ping'in Google'a Forward edilmesi lazım ki Firewall'un üzerinde geçebilsin. <br>
          Bu durumda 3. olanın işaretlenmiş olması gerekir. <br>
          Çünkü Gateway dediğimiz şey zaten Firewall kurulduğu andan itibaren Firewall'un kendisidir. <br>
          Yukarıdaki ilk madde işaretlenmemiş olsaydı, Firewall'a yani Gateway'e Ping atılamazdı.
        </p>
        <p>
          Peki Gateway'in kendisinden yani Firewall'dan bir yere nasıl Ping atacağız?
        </p>
        <p class="bg-script">
          > Support <br>
          > Tools <br>
          > Ping Check <br>
          -> Ping host -> Hangi makineye Ping atmak istediğimizi seçeriz. <br>
          > Apply -> Dediğimizde Ping atmaya başlar.
        </p>
        <p>
          Yukarıdaki konumdan ihtiyaç durumunda Ping testlerini de yapabiliyoruz özetle.
        </p>

        <h6>Traceroute Settings</h6>
        <p>
          tracert -d 8.8.8.8
          -> Yukarıdaki komutu CMD'ye girersek, bize bizim Ping attığımız yani bu komutu yazdığımız makineden 8.8.8.8'e giderken ki tüm HOP'larını gösterir. <br>
          Yani üzerinden geçtiği tüm Router'ları yani Network'leri özetle ayak izlerini yazdırır diyebiliriz.
        </p>
        <p>
          []Gateway is traceroute visible -> İşaretlersek; Firewall'un kendisinden Traceroute yapabiliriz. <br>
          []Gateway forwards traceroute -> İşaretlersek; Traceroute paketlerini Firewall'un üzerinde geçirir.
        </p>
        <p>
          Gateway'in kendisinden Traceroute paketini nasıl atacağız?
        </p>
        <p class="bg-script">
          > Support <br>
          > Tools <br>
          > Traceroute  <br>
          > Traceroute host: -> Traceroute atmak istediğimiz Host'u gireriz. <br>
          -> istersek direkt IP adresini girerek de Tracerouting yapabiliriz.
        </p>

        <p>
          Tools'un altında ekstradan DNS Lookup adında bir sekme daha vardır. <br>
          Bu sekme bize IP'sini girdiğimiz Domain'deki kayıt tiplerini ve kayıtları görebiliriz, tabi izin verilmişse. <br>
          Örneğin 8.8.8.8'i girersek, Google'ın MX kaydını görebiliriz. <br>
          Yani Google'ın Mail Server'ının ismini buradan öğrenebiliriz.
        </p>

        <h6>Global ICMP Settings</h6>
        <p>
          Ping dediğimiz paket ICMP protokolünün bir parçasıdır. <br>
          Internet Control Message Protocol açılımıdır. <br>
          Ping paketleri ICMP paketlerini kullanırlar. <br>
          Fakat ICMP protokolünü kullanan başka uygulamalar da olabilir. <br>
          Sadece Ping atılabilmesini istiyorsak, yukarıda uyguladığımız gibi Ping Setting'i Enable etmemiz yeterlidir. <br>
          Fakat başka ICMP kullanan başka bir uygulama var ise onun geçişlerini de ICMP sekmesinden açarız. 
        </p>

        <h5>NAT</h5>
        <p>
          Firewall NAT'lama işlemini de yapabilir. <br>
          Internal Network'lerimizde ücretsiz yani Private IP'ler kullanıyoruz. <br>
          Yani tüm cihazlarımıza bu IP'ler dağıtılmış durumda. <br>
          Fakat bu IP'ler normalde internete çıkamazlar, dolayısıyla bu cihazlardan internete çıkılmak istendiğinde Firewall üzerinden sahip oldukları Private IP'leri internete çıkabilen gerçek IP'imize NAT'layabiliriz. <br>
          Zaten bu işlem yapılmadan internete çıkmak diye bir durum olamaz. <br>
          Burada Router'ların yaptığı gibi Firewall'un da aynı hizmeti sağlayabildiğini görüyoruz.
        </p>
        <p>
          Firewall kurulurken Setup'ta varsayılan olarak NAT'ı açar. <br>
          Sophos Private IP'leri tek bir IP üzerinden dışarıya çıkartmaya NAT değil de Masquerading adını vermiştir. <br>
          Bunu yapabilmek içinde varsayılanda Internal Network'ten Uplink Interfaces'e NAT'lama kuralını yazmıştır. <br>
          Uplink Interfaces; bizi internete bağlayan External Interface'lerdir. <br>
          Firewall'daki trafiği anında durdurmak istiyorsak, bu kuralı yani NAT'lama hizmetini yapan kuralı Disable edersek, artık Network'lerden kimse dışarıya çıkamaz, anında internet bağlantısı kesilir.
        </p>

        <h6>NAT</h6>
        <p>
          SOPHOS üzerinde NAT'ın altında bir NAT sekmesi daha vardır. <br>
          Bu isimlendirme diğer Firewall'larda bu şekilde olmayabilir. <br>
          NAT'lama servisinin yapacağı iki iş vardır. <br>
          Birincisi Internal'ı dışarıya çıkarmak, ikincisi ise External'ı içeriye almak. <br>
          Son söyledeğimiz durum Negative'tir. <br>
          Diyelim ki Internal Network'ümüzde bir tane Web Server'ımız var. <br>
          Dışarıdan bu Web Server'a gelmemiz gerekecek, geleceğimiz yer maksimum Firewall'un dış bacağı olacaktır. <br>
          Firewall, Web Server olmadığı için normal şartlarda gelen paketleri reddeder. <br>
          Reddetmemesi için; Port Forwarding yani NAT'lama yapması gerekiyor. <br>
          Yani dışarıdaki talebi iç Network'e NAT'laması gerekiyor. <br>
          Bunu uygulayarak örneklendirebiliriz;
        </p>
        <p>
          Bunun için sanalda Internal Network'e IIS kuruyoruz. <br>
          IIS'te şirketin Binding'ine www.sirket3.com gir. <br>
          Internal'daki DNS'te www Host haydı aç, Web Server'ın IP'sini gir. <br>
          Şuanda Internal'dan bu Web sayfasına erişimimiz olur. <br>
          Fakat şuanda bu Network'ün dışından birisi tarayıcıya gidip www.sirket3.com yazarsa sayfaya erişemez. <br>
          Çünkü öncelikle bu ismi çözemez. <br>
          Bunun için normalde bir Domain satın alınır, içine kayıt girilir vs. <br>
          Sanal'da deneme amacıyla bununla uğraşmak için fiziksel makineye gidip;
          This PC/C/Windows/System32/drivers/etc/hosts dosyasını Notepad ile açarız. <br>
          Bu sayfada en alta Firewall'un External IP'sini yazarız. <br>
          Örneğin; 10.3.34.100 www.sirket3.com
        </p>
        <p>
          Şimdi yukarıda Domain'ini satın almışız gibi bir taklit yaptık, şuanda dış makineden siteye erişmek istediğimizde isim çözümlemesi yapılabilse bile erişim olmayacak. <br>
          Çünkü Firewall bizim paketlerimizi içeriye alamıyor. <br>
          Firewall'u yöneten Admin, Network Protection'dan NAT'ın altındaki NAT başlığına gidip; New NAT Rules'a tıklayarak aşağıdaki gibi yeni bir kural yazmalı;
        </p>
        <p class="bg-script">
          > Network Protection <br>
          > NAT <br>
          > NAT <br>
          > New NAT Rules <br>
          > Rule type: DNAT -> Dynamic olarak NAT yap anlamına gelir. <br>
          > For traffic from: Any -> Herhangi bir yerden geliyorsa... <br>
          > Using Service: Örneğin HTTP <br>
          > Going to External(WAN) -> Firewall'un dış bacağı. <br>
          > Action <br>
          -> Change the destination to: IIS -> Web Server'ın olduğu makineye götür.<br>
          -> And the service to: HTTP -> HTTP servisi ile götür. <br>
          [+]Automatic firewall rule
          -> İşaretlersek yukarıdaki hizmeti gerçekleştirebilmek için otomatik olarak gerekli Firewall kuralını yazmasını sağlar. <br>
          > Save
        </p>
        <p>
          Yukarda otomatik olarak kural yazmasını seçmezsek, Rules'e gidip Manuel olarak dışarıdan Any -> 80-80 Protokolü ile -> IIS'e gidiliyorsa izin ver şeklinde bir kural yazmamız gerekirdi. <br>
          Rules ekranında otomatik olarak yazılmış kuralları görebilmek için yukarıdaki sekmeden Automatic firewall rules veya Alls seçilebilir.
        </p>
        
        <hr>
        
        <div class="text-center container p-3 bg-script">
          <div class="d-flex justify-content-evenly navigation">
            <a href="16-04-2023.html" class="bg-script">16.04.2023</a>
            <a href="30-04-2023.html" class="bg-script">30.04.2023</a>
          </div>
        </div>
        

    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>
  </body>
</html>